###############
#INTAL LIBRARY#
###############
INTRODUCTION
-----------------------------------------------------------------------------------------------------------------------------------------------
An Intal is a nonnegative integer of arbitrary length(INTAL is short form for integer of arbitrary length).An integer is datatype in c which takes 4 bytes of memory and its range is -2,147,483,648 to 2,147,483,647 now if we take unsigned also then its tough to assign a vey large number such as 10^10 or bigger than that and its obvious that in today's world these type of values are possible mostly in scientific purpose hence there is a need of arbitrary length integer.The functionality of the library is to perform arithmetic operations like Addition , Subtraction , Multiplication , Division and Exponentiation and many more.
-----------------------------------------------------------------------------------------------------------------------------------------------Applications of intal
- Large numbers factorial : 32 bit unsigned integers store only up to 12!
- can be used in scientific calculations where normal calculator can't be used.	
- Cryptography: One of the most popular asymmetric encryption algorithms is Rivest–Shamir–Adleman. RSA uses a pair of key - public and private keys - to encrypt a message. To be secure, the keys need to be very very large numbers (the recommended size is 3072 bits). It might be possible to represent the keys in standard integers, but the decryption and encryption process involves computation of power between those large numbers (sometimes even multiple powers) along with modulus. This is commonly called modular exponentiation. With standard 32-bit or 64-bit this would overflow very easily. Hence, intal is a good use-case for RSA cryptography.
- High-resolution timestamps
-------------------------------------------------------------------------------------------------------------------------------------------------
functionalities
1)int intal_compare(const char* intal1, const char* intal2):intal_compare takes two parameters as intals(intal1 and intal2) and then we are iterating from index 0 of each intal that if intal1[i]>intal2[i] then intal1 is greater otherwise intal2 is greater, the base cases are that whichever's length is greater that will be larger than the other, and if all above cases fails then both are equal.
	if they are equal then 0 is returned
	if intal1 is greater than 1 is returned
	else -1 is returned 
2)char* intal_add(const char* intal1, const char* intal2):intal_add takes two parameter as intal1 and intal2, the intals which are to be added. We first compare both the intals and whichever is greater we assign it to i1 and the other to i2 (psedo name for intals), offset is calculated (strlen(i1)-strlen(i2)) for further use, now we start with the smaller intal we try to traverse from backwards since we know that arithmetic operation starts from backwards and then we find sum using i1[offset+i]+i2[i]+c for each digit and in that we are subtracting '0' to get the equivalent numerical value and then after getting sum we are assigning carry to be sum/10 for further iterations and in result of [index](index in code is 'k' which is assigned the value of l1) we are storing sum%10. After all the iterations we will be getting result intal but with (may or may not be zero in front) for that we are calling remove zero function(helper function)# refer at bottom.

3)char* intal_diff(const char* intal1, const char* intal2):intal_diff takes two parameter as intal1 and intal2, the intals which are to be subtracted .We first compare both the intals and whichever is greater we assign it to i1 and the other to i2 (psedo name for intals), offset is calculated (strlen(i1)-strlen(i2)) for further use, now we start with the smaller intal we try to traverse from backwards since we know that arithmetic operation starts from backwards and then we find 'dif'(variable) using i1[offset+i]-i2[i]-c for each digit and in that we are subtracting '0' to get the equivalent numerical value and then after getting dif we are checking that if its less than 0 then we have to do dif+=10 to make it positive and carry as 1 (basically how we do in pen paper) otherwise if dif>0 then carry is 0 only, for further iterations and in result of [index](index in code is 'k' which is assigned the value of l1) we are storing dif+'0'.after that we are iterating through the greater intal to calculate with the leftovers, After all the iterations we will be getting result intal but with (may or may not be zero in front) for that we are calling remove zero function(helper function)# refer at bottom.

4)char* intal_multiply(const char* intal1, const char* intal2):intal_multiply takes two parameters as intals.First we compare both the intals and assign i1 as larger of two and the other one as i2.we dynamically assigned result array. Now we are iterating from i2(smaller intal) and then inside the loop for each element in i2 we are multiplying with each element of i1(bigger intal) and for each inner loop we are calculating product,carry and storing respectively i.e prod=i2[i](outer loop)*i1[j](for each element of i1)+c, and carry(here c) will be prod/10 which will be used in further inner iterations and after each inner loop we are calling remove zero helper functions as there may be some zeros in front. and then we are calling intal_add to add result and the temporary array which we got after inner loop and finally the result will be in result array(res here).

5)char* intal_mod(const char* intal1, const char* intal2) Description : Returns intal1 mod intal2
Approach : If intal1 < intal2 , then the number represented by intal1 is returned through a temporary pointer 'temp'. The result is obtained through long division with a twist to reduce the number of iterations.'n1' and 'n2' are integer variables which are used to store the lengths of intal1 and intal2 respectively. 'temp' now has copy of intal1. A new dividend of size n2 is created using the 'dividend()' function and stored in 'new_div'. If 'new_div' < temp , then new dividend of size n2+1 is created. Once 'new_div' is obtained intal_diff(new_div, intal2) is assigned to 'new_div'. If the difference is '0' then the rest of the dividend is brought down using 'dividend()' by giving start=n_div and end=n1 where 'n_div' is the length of 'new_div'. If the difference is non zero then 'new_div' is assigned to the concatenation of the non zero difference and the rest of the main dividend using 'dividend()'. This process repeated till the temp>=intal2 with the help of a while loop. 'temp' is passed to remove_zero() to remove all leading zeros and it is returned.In traditional long division, each digit is brought down one by one after the first subtraction. To reduce the number of iterations and subtractions, the entire remaining dividend is brought down. This solves the problem in efficient time (log(intal1)).

6)char* intal_pow(const char* intal1, unsigned int n):(constraint:to execute in O(log(n)))In power function the bases cases are if intal1 is 0 then returned value is zero else if the value of n is 0 then the returned value is 1 else, initially we are stroring the value of intal1 in temp variable p now if value of n is odd we are calling intal_multiply with intal1 and p else we are squaring the value of p i.e intal_multiply with parameters as p and p and this is inside a while loop which will stop iterating once the value of n becomes 0. inside the loop we are doing n=n/2(this only making it into )(logn))).finally the result array is returned having the power of intal1

7)char* intal_gcd(const char* intal1, const char* intal2):(constraint:to execute in O(log(n)))intal_gcd takes two paramters as intals.The Basic idea behind the gcd function is that if the value of intal1 is 0 then the intal2 is returned(this is a recursive function-euclid's theorem) else recursively we call intal_gcd with the parameters as intal_mod(intal2,intal1) and intal1 that is in simple terms for a,b if a==0 return b else gcd(b%a,a). 

8)char* intal_fibonacci(unsigned int n):Parameter for fibonacci function is unsigned int n.initially we are declaring variable a dynamically and assigning the value 0 to it and the base case is if n==0 return a(i.e 0) else if n==1 then return 1(copy 1 to a and then return a) else,
for make another variable b and assign 1 to it and a temp variable c. now iterate n times and perform c=intal_add(a,b),a=b,b=c and after all the iterations are over the final result will be in variable b.

9)char* intal_factorial(unsigned int n):the parameter for factorial function is unsigned int n. we are dynamically allocating result array to store the factorial. we are creating a temp variable to store the count so that we can multiply it with result.The loop is iterating from 1 to n and each time we are calling intal_multiply function to perform multiplication. we are multiplying result with factorial and we are increasing factorial count by 1. So basically the factorial is like fact(n)=n*1*2*3....(n-1).

10)char* intal_bincoeff(unsigned int n, unsigned int k):The binomial coefficient is calculated using the concept of the pascal's triangle by using a window of size k. If k is greater than n / 2, k is set to n - k to save time since n C k = n C (n - k). Each element of the triangle array is an intal which is initialised to "0" and the first row initialised to "1".According to Pascal's identity, n C k = ((n - 1) C (k - 1)) + ((n - 1) C k. In the Pascal's triangle, this means that the current term is equal to the sum of the 2 elements directly above it, i.e, elements at the jth and (j - 1)th index. The coefficients are calculated only upto k since after k, the coefficients would be repeated which is not required.This algorithm takes O(n * k) time.


11)int intal_max(char **arr, int n):The parameters to the intal_max function is an array and the sizeof the array. We are initializing a temp variable and storing the first element of the array. Then we are iterating from the 1st location till n. and we are calling intal_compare to check if arr[i] is greater then the temp_max(maximum in my case) then we are changing the maximum to the current value and the current location as max index and then finally we are returning max_index.

12)int intal_min(char **arr, int n):The parameters to the intal_max function is an array and the sizeof the array. We are initializing a temp variable and storing the first element of the array. Then we are iterating from the 1st location till n. and we are calling intal_compare to check if arr[i] is smaller then the temp_min(min in my case) then we are changing the minimum to the current value and the current location as min index and then finally we are returning min_index.

13)int intal_search(char **arr, int n, const char* key):The parameter is an array and the key to be searched for. we are iterating through the array if the key is present then we return the respective index and after the end of the loop if the key is not present then -1 is returned.

14)void intal_sort(char **arr, int n) :(constraint:need to be done in nlog(n) and inplace) i have followed the merge sort algorithm in which we have two helper function one is mergesort and another is merge. mergesort takes the array and the left and the right index then it starts dividing the array into two halves and again it calls mergesort to those divided arrays and it continue till the size of each array becomes one then it calls the merge function which takes the array and based on the condition. it makes two arrays from left to mid and from mid+1 to right.
then it starts comparing and based on the comparison the result is stored in the result arr.and once one of the array becomes empty the values from the other gets copied into the final result array.

15)int intal_binsearch(char **arr, int n, const char* key):The parameters for the intal_binsearch are the array, the size of the array and the key to searched for.First we initialize the variables as i,j,m(middle). then we check that if j>=i(otherwise no need to go inside loop i.e the right index is less than left which is not possible).We calculate the mid by using the formula i+(j-i)/2(to handle overflow) then we compare the key and the arr[m] if the returned value is 0 then we return mid value otherwise we compare that if arr[m] is lesser or greater than key and we assign the variable based on the comparison value. Basically we are dividing the array each time by half.

16)char* coin_row_problem(char **arr, int n): The coin row problem is as follows: Given an array of n coins, one must determine the right coins to be selected such that the maximum value is obtained from these coins, subject to the constraint that no two adjacent coins can be selected,
In order to explore all the possibilites, a binary tree is constructed where the left branch assumes that the last element of its array is taken and the right branch assumes that it is not taken. At each such branch, the element taken is removed from the array and its cost is added to the final resulting cost to be returned. From this tree, the following recurrence can be obtained: f(n) = max{C(n - 1) + f(n - 2), f(n - 1)} where f(0) = 0 and f(1) = 1.The recurrence can be implemented as a memoization solution which uses the same relation but with a memoization table. So instead of the recurrence stack we will have a memoization table that stores the intermediate results. When this memoization solution is implemented from bottom-up, it is known as the DP solution. However, to compute only the optimal value and not the optimal solution, a sliding window can be used. The following is the pseudocode for obtaining the optimal value.
    prev = 0
    curr = arr[0]
    for i = 2 to n:
      if (prev + arr[i - 1] > curr):
        next = arr[i - 1] + prev
        prev = curr
        curr = next

      else:
        prev = curr

    return curr
###helper function###
remove_zero:in this i am taking the result string and then searching for the first non zero element's index so that from there i am storing all the non zero values into the result string and at last if the all are are zero's that is final index will be equal to the length of the input string then the value "0" is returned.

create_dividend:we are returning the substring of the dividend.
add_helper:helper function used in coin row problem(same as intal add but with extra parameters)
------------------------------------------------------------------------------------------------------------------------------------------------
3. Future Work
a. More functionality
One functionality that would be useful in cryptography is an efficient modular exponentiation, that is power with mod. The current implementation would be insufficient for RSA cryptography. It could also be extended to work with arbitrary size intals instead of the 1000 limit which is currently imposed.